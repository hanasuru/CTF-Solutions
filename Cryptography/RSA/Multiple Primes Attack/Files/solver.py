# From https://crypto.stackexchange.com/questions/31109/rsa-enc-decryption-with-multiple-prime-modulus-using-crt
ts = []
xs = []
ds = []
primes = [3773485921,3434930489,3028717567,2595426653,4133066557,2809102039,2985163057,2417678233,2210112469,2524157653,3078545441,2800965221,2713731701,2494424651,3643099153,2758883167,2973850937,3060778823,4211395609,2718714109,3478015441,2633925121,2469371521,2473431377,2227787323,4033743143,2825979151,3510193961,2290524781,3580761619,3164053979,3885700349]
e = 65537
c = 211233878176139958404264864209276548836073766408962213554876211225652027343113429221187522541182642685647999344384807451081287402332098958213676333486774233116222632100844757917639115574044159777833250740253012442523557091943410364730891140615382869151456431822061635559148980124882138478019629198137325
n = 1464630312725039231276429358568992592864466838554723082742829483040979639659295957499415607171079112878465605003475149561993978197873242605285251650125725630269762474254341508914762555366854195720167218237220862915065201853626822042026436665859784729163981831668307963361886151330939097572475015730075093
def egcd(a, b):
    if a == 0:
        return (b, 0, 1)
    g, y, x = egcd(b%a,a)
    return (g, x - (b//a) * y, y)

def modinv(a, m):
    g, x, y = egcd(a, m)
    if g != 1:
        raise Exception('No modular inverse')
    return x%m

for i in range(len(primes)):
	ds.append(modinv(e, primes[i]-1))

m = primes[0]

for i in range(1, len(primes)):
	ts.append(modinv(m, primes[i]))
	m = m * primes[i]

for i in range(len(primes)):
	xs.append(pow((c%primes[i]), ds[i], primes[i]))

x = xs[0]
m = primes[0]

for i in range(1, len(primes)):
	x = x + m * ((xs[i] - x % primes[i]) * (ts[i-1] % primes[i]))
	m = m * primes[i]


print hex(x%n)[2:-1].decode("hex")
